# -*- coding: utf-8 -*-
"""PSO-Rastrigin

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RfBBCkaw0vEvly5ZkpR7ZrKwYaJohvV6
"""

import ipywidgets as widgets
from IPython import display as display

import matplotlib.pyplot as plt
import numpy as np

from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter
from mpl_toolkits.mplot3d import Axes3D
A = 10.0

def f(X):
    delta = [x**2 - A * np.cos(2 * np.pi * x) for x in X]
    y = A + sum(delta)
    return y


rastrigin = lambda x1,x2,x3: ((x1**2 - A * np.cos(2 * np.pi * x1))+(x2**2 - A * np.cos(2 * np.pi * x2))+(x3**2 - A * np.cos(2 * np.pi * x3)))

def create_button():
  button = widgets.Button(
    description='Next Iteration',
    disabled=False,
    button_style='', # 'success', 'info', 'warning', 'danger' or ''
    tooltip='Next Iteration',
    icon='check' # (FontAwesome names without the `fa-` prefix)
  )
  return button

def graph_f():
 
  X1 = np.arange(-5, 5, 0.15)
  X2 = np.arange(-5, 5, 0.15)
  X3 = np.arange(-5, 5, 0.15)


  x1,x2=np.meshgrid(X1, X2)
  _,x3=np.meshgrid(X2, X3)

  z1=rastrigin(x1,x2,x3)

  # Plotear funcion 
  fig = plt.figure(figsize=(8,5))
  ax = fig.gca(projection='3d')

  surf = ax.plot_surface(x1,x2,z1, rstride=1, cstride=1, cmap=cm.coolwarm, linewidth=0, antialiased=False)  
  
  ax.zaxis.set_major_locator(LinearLocator(10))
  ax.zaxis.set_major_formatter(FormatStrFormatter('%.02f'))
  fig.colorbar(surf, shrink=0.5, aspect=5)
 

def graph_population(X,V):
  y=list(map(f,X))   #0

  graph_f()     #Graficar funcion
  
  plt.plot(X[:,0],X[:,1],y,'go')   #Grafica las particulas ('g' de green y 'o' de punto)
  plt.plot([X_gbest[0]],[X_gbest[1]],[f(X_gbest)],'r*',markersize=15)   #Grafica el Lider
  for i in range(n_particles):
    x1=X[i][0]
    x2=X[i][1]

    v1=V[i][0]
    v2=V[i][1]

    plt.plot([x1,x1+2*v1],[x2,x2+2*v2],[y[i],y[i]],'c')    #Grafica la velocidad de las particulas

lower_limit=-4
upper_limit=4

n_particles=15
n_dimensions=4

# Initialize the particle positions and their velocities
#X = lower_limit + (upper_limit - lower_limit) * np.random.rand(n_particles, n_dimensions) 
#Bias the initial population
X = upper_limit + 0.25*(upper_limit - lower_limit) * np.random.rand(n_particles, n_dimensions)

assert X.shape == (n_particles, n_dimensions)
# V = np.zeros(X.shape)
V = -(upper_limit - lower_limit)/2+(upper_limit - lower_limit)*np.random.rand(n_particles, n_dimensions)

 
# Initialize the global and local fitness to the worst possible
fitness_gbest = np.inf
fitness_lbest = fitness_gbest * np.ones(n_particles)

X_lbest=1*X
X_gbest= 1*X_lbest[0]

fitness_X = np.zeros(X.shape)

for i in range(0, n_particles): #for p in X_lbest:  
  if f(X_lbest[i])<f(X_gbest):
    X_gbest=1*X_lbest[i]

count=0

weight=0.8    #Inercia

C1=0.75    #Individualismo

C2=1.0    #Influencia del lider en las particulas


def iteration(b):
    global count
    global weight, C1, C2
    global X,X_lbest,X_gbest,V

 
    display.clear_output(wait=True)
    display.display(button)
    count+=1

    print (count,"Best particle in:",X_gbest," gbest: ",f(X_gbest))

    # Update the particle velocity and position
    for I in range(0, n_particles):
        for J in range(0, n_dimensions):
          R1 = np.random.rand()#uniform_random_number()
          R2 = np.random.rand()#uniform_random_number()
          V[I][J] = (weight*V[I][J]
                    + C1*R1*(X_lbest[I][J] - X[I][J]) 
                    + C2*R2*(X_gbest[J] - X[I][J]))
          X[I][J] = X[I][J] + V[I][J]
        if f(X[I])<f(X_lbest[I]):
            X_lbest[I]=1*X[I]
            if f(X_lbest[I])<f(X_gbest):
                X_gbest=1*X_lbest[I]
          
    graph_population(X,V)


button=create_button()
button.on_click(iteration)
display.display(button)

graph_population(X,V)